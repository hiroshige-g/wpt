<!DOCTYPE html>
<meta charset="utf-8">
<title>Moving script elements between documents</title>
<link rel="author" href="mailto:d@domenic.me" title="Domenic Denicola">
<link rel="help" href="https://html.spec.whatwg.org/multipage/#execute-the-script-block">

<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>

<!-- Background:

- https://www.w3.org/Bugs/Public/show_bug.cgi?id=11323
- https://github.com/whatwg/html/issues/2137
- https://github.com/whatwg/html/issues/2469
- https://github.com/whatwg/html/pull/2673

-->

<body>
<script>
"use strict";

function createDocument(documentType) {
  return new Promise((resolve, reject) => {
    const iframe = document.createElement("iframe");
    iframe.onload = () => {
      if (documentType === "iframe") {
        resolve([iframe.contentWindow, iframe.contentDocument]);
      } else if (documentType === "createHTMLDocument") {
        resolve([
            iframe.contentWindow,
            iframe.contentDocument.implementation.createHTMLDocument("")]);
      } else {
        reject(new Error("Invalid document type: " + documentType));
      }
    };
    document.body.appendChild(iframe);
  });
}

window.scriptErrorEventFired = false;
window.didExecute = undefined;

(async function() {
  for (const during of ["parsing", "successful fetch", "failed fetch"]) {
    for (const hasParseError of [false, true]) {
      for (const destType of ["iframe", "createHTMLDocument"]) {
        for (const type of ["text/javascript", "module"]) {
          if (during === "failed fetch" && hasParseError) {
            // Skip; Parse errors can't occur for failed fetches.
            continue;
          }

          const description =
              `Move during ${during}` +
              (hasParseError ? " with parse error" : "") +
              ` to ${destType} document: ${type}`;
          const t = async_test(description + ", script evaluation");
          const tScriptLoadEvent = async_test(description + ", script load");
          const tScriptErrorEvent = async_test(description + ", script error");
          const tWindowErrorEvent = async_test(description + ", window error");

          const [sourceWindow, sourceDocument] =
              await createDocument("iframe");
          const [destWindow, destDocument] = await createDocument(destType);

          let scriptErrorEventFired = false;

          sourceWindow.didExecute = undefined;
          sourceWindow.tScriptLoadEvent = tScriptLoadEvent;
          sourceWindow.tScriptErrorEvent = tScriptErrorEvent;
          sourceWindow.onerror = tWindowErrorEvent.unreached_func(
              "Window error event shouldn't fired on source window");
          destWindow.didExecute = undefined;
          destWindow.tScriptLoadEvent = tScriptLoadEvent;
          destWindow.tScriptErrorEvent = tScriptErrorEvent;
          destWindow.onerror = tWindowErrorEvent.unreached_func(
              "Window error event shouldn't fired on destination window");

          const shouldScriptErrorEventFired = false;
          // TODO: Temporarily set to false just to test behaviors on
          // the current browsers.
          // during === "failed fetch" && destType === "iframe";

          if (during === "parsing") {
            sourceDocument.write("<streaming-element>");
            destDocument.body.appendChild(
              sourceDocument.querySelector("streaming-element"));
            sourceDocument.write(
              `<script id="s1" type="${type}"
                  onload="tScriptLoadEvent.unreached_func('onload')"
                  onerror="tScriptErrorEvent.unreached_func('onerror')">`);
            if (hasParseError) {
              sourceDocument.write("1=2 parse error<" + "/script>");
            } else {
              sourceDocument.write("window.didExecute = true;<" + "/script>");
            }
            sourceDocument.write("</streaming-element>");
            sourceDocument.close();
          } else { // Move during fetching
            const s = sourceDocument.createElement("script");
            s.type = type;

            s.onload = tScriptLoadEvent.unreached_func("onload");
            if (shouldScriptErrorEventFired) {
              s.onerror = () => { scriptErrorEventFired = true };
            } else {
              s.onerror = tScriptErrorEvent.unreached_func("onerror");
            }

            if (during === "successful fetch") {
              if (hasParseError) {
                s.src = "resources/slow-flag-setter.py?result=parse-error";
              } else {
                s.src = "resources/slow-flag-setter.py?result=successful";
              }
            } else {
              s.src = "resources/slow-flag-setter.py?result=failed";
            }
            sourceDocument.body.appendChild(s);
            // Need to delay since the "prepare a script" algorithm also
            // contains related checks; we want to test the
            // "execute a script block" algorithm for when the fetch comes
            // back.
            t.step_timeout(() => {
              destDocument.body.appendChild(s);
            }, 0);
          }

          // As we have concurrent tests, a single global step_timeout() is
          // used instead of multiple `t.step_timeout()` etc.,
          // to avoid potential race conditions between `t.step_timeout()`s.
          step_timeout(() => {
            tScriptLoadEvent.done();
            tScriptErrorEvent.step_func_done(() => {
              if (shouldScriptErrorEventFired) {
                assert_true(scriptErrorEventFired,
                    "error event should be fired");
              }
            })();
            tWindowErrorEvent.done();
            t.step_func_done(() => {
              assert_equals(sourceWindow.didExecute, undefined,
                "The script must not have executed in source window");
              assert_equals(destWindow.didExecute, undefined,
                "The script must not have executed in destination window");
            })();
          }, 2000);
        }
      }
    }
  }

  async_test(t => {
      t.step_timeout(() => {
          assert_equals(window.didExecute, undefined,
            "The script must not have executed in the top-level window");
          assert_false(window.scriptErrorEventFired,
            "Top-level window's scriptErrorEventFired should be untouched");
          t.done();
        }, 2000);
    },
    "Sanity check around top-level Window");
})();
</script>
