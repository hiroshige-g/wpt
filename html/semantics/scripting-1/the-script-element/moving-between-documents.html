<!DOCTYPE html>
<meta charset="utf-8">
<title>Moving script elements between documents</title>
<link rel="author" href="mailto:d@domenic.me" title="Domenic Denicola">
<link rel="help" href="https://html.spec.whatwg.org/multipage/#execute-the-script-block">

<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>

<!-- Background:

- https://www.w3.org/Bugs/Public/show_bug.cgi?id=11323
- https://github.com/whatwg/html/issues/2137
- https://github.com/whatwg/html/issues/2469
- https://github.com/whatwg/html/pull/2673

-->

<body>
<script>
"use strict";

function createDocument(documentType) {
  return new Promise((resolve, reject) => {
    const iframe = document.createElement("iframe");
    iframe.onload = () => {
      if (documentType === "iframe") {
        resolve([iframe.contentWindow, iframe.contentDocument]);
      } else if (documentType === "createHTMLDocument") {
        resolve([
            iframe.contentWindow,
            iframe.contentDocument.implementation.createHTMLDocument("")]);
      } else {
        reject(new Error("Invalid document type: " + documentType));
      }
    };
    document.body.appendChild(iframe);
  });
}

window.scriptErrorEventFired = false;
window.didExecute = undefined;

(async function() {
  for (const during of ["parsing", "successful fetch", "failed fetch"]) {
    for (const destType of ["iframe", "createHTMLDocument"]) {
      for (const type of ["text/javascript", "module"]) {
        const description =
            `Move during ${during} to ${destType} document: ${type}`;
        const t = async_test(description + ', script evaluation');
        const tEvent = async_test(description + ', load/error events');

        const [sourceWindow, sourceDocument] = await createDocument("iframe");
        const [destWindow, destDocument] = await createDocument(destType);

        let scriptErrorEventFired = false;

        sourceWindow.didExecute = undefined;
        sourceWindow.tEvent = tEvent;
        destWindow.didExecute = undefined;
        destWindow.tEvent = tEvent;

        const shouldErrorEventFired =
          during === "failed fetch" && destType === "iframe";

        if (during === "parsing") {
          sourceDocument.write("<streaming-element>");
          destDocument.body.appendChild(
            sourceDocument.querySelector("streaming-element"));
          sourceDocument.write(
            `<script id="s1" type="${type}"
                     onload="tEvent.unreached_func('onload')"
                     onerror="tEvent.unreached_func('onerror')">
            window.didExecute = true;<` + "/script>"
          );
          sourceDocument.write("</streaming-element>");
          sourceDocument.close();
        } else { // Move during fetching
          const s = sourceDocument.createElement("script");
          s.type = type;

          s.onload = tEvent.unreached_func("onload");
          if (shouldErrorEventFired) {
            s.onerror = () => { scriptErrorEventFired = true };
          } else {
            s.onerror = tEvent.unreached_func("onerror");
          }

          if (during === "successful fetch") {
            s.src = "resources/slow-flag-setter.py?result=successful";
          } else {
            s.src = "resources/slow-flag-setter.py?result=failed";
          }
          sourceDocument.body.appendChild(s);
          // Need to delay since the "prepare a script" algorithm also
          // contains related checks; we want to test the
          // "execute a script block" algorithm for when the fetch comes back.
          t.step_timeout(() => {
            destDocument.body.appendChild(s);
          }, 0);
        }

        // As we have two concurrent tests (`tEvent` and `t`),
        // a single global step_timeout() is used instead of two
        // `tEvent.step_timeout()` and `t.step_timeout()`,
        // to avoid potential race conditions between two step_timeout()s.
        step_timeout(() => {
          tEvent.step_func_done(() => {
            if (shouldErrorEventFired) {
              assert_true(scriptErrorEventFired,
                  "error event should be fired");
            }
          })();
          t.step_func_done(() => {
            assert_equals(sourceWindow.didExecute, undefined,
              "The script must not have executed in source window");
            assert_equals(destWindow.didExecute, undefined,
              "The script must not have executed in destination window");
          })();
        }, 2000);
      }
    }
  }

  async_test(t => {
      t.step_timeout(() => {
          assert_equals(window.didExecute, undefined,
            "The script must not have executed in the top-level window");
          assert_false(window.scriptErrorEventFired,
            "Top-level window's scriptErrorEventFired should be untouched");
          t.done();
        }, 2000);
    },
    "Sanity check around top-level Window");
})();
</script>
