<!DOCTYPE html>
<meta charset="utf-8">
<title>Moving script elements between documents</title>
<link rel="author" href="mailto:d@domenic.me" title="Domenic Denicola">
<link rel="help" href="https://html.spec.whatwg.org/multipage/#execute-the-script-block">

<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>

<!-- Background:

- https://www.w3.org/Bugs/Public/show_bug.cgi?id=11323
- https://github.com/whatwg/html/issues/2137
- https://github.com/whatwg/html/issues/2469
- https://github.com/whatwg/html/pull/2673

-->

<body>
<script>
"use strict";

for (const type of ["text/javascript", "module"]) {
  async_test(t => {
    window.t = t;

    t.add_cleanup(() => {
      window.didExecute = undefined;
      window.t = undefined;
    });

    const iframe = document.createElement("iframe");
    iframe.onload = t.step_func(() => {
      iframe.contentWindow.t = t;

      iframe.contentDocument.write("<streaming-element>");
      document.body.appendChild(iframe.contentDocument.querySelector("streaming-element"));
      iframe.contentDocument.write(
        `<script id="s1" type="${type}"
                 onload="t.unreached_func('onload')"
                 onerror="t.unreached_func('onerror')">
        window.didExecute = true;<` + "/script>"
      );
      iframe.contentDocument.write("</streaming-element>");

      iframe.contentDocument.close();

      // Needs a delay to allow any error/load events to fire (and fail the test if they do).
      t.step_timeout(() => {
        assert_equals(window.didExecute, undefined, "The script must not have executed in this window");
        assert_equals(iframe.contentWindow.didExecute, undefined,
          "The script must not have executed in the iframe window");
        t.done();
      }, 1000);
    });

    document.body.appendChild(iframe);
  }, `${type}: moving to another document during parsing, inline script`);

  async_test(t => {
    window.t = t;
    t.add_cleanup(() => {
      window.didExecute = undefined;
      window.t = undefined;
    });

    const iframe = document.createElement("iframe");
    iframe.onload = t.step_func(() => {
      iframe.contentWindow.t = t;

      iframe.contentDocument.write("<streaming-element>");
      document.body.appendChild(iframe.contentDocument.querySelector("streaming-element"));
      iframe.contentDocument.write(
        `<script id="s1" type="${type}" src="resources/flag-setter.js"
                 onload="t.unreached_func('onload')"
                 onerror="t.unreached_func('onerror')">
        <` + "/script>"
      );
      iframe.contentDocument.write("</streaming-element>");

      iframe.contentDocument.close();

      // Needs a delay to allow any error/load events to fire (and fail the test if they do).
      t.step_timeout(() => {
        assert_equals(window.didExecute, undefined, "The script must not have executed in this window");
        assert_equals(iframe.contentWindow.didExecute, undefined,
          "The script must not have executed in the iframe window");
        t.done();
      }, 1000);
    });

    document.body.appendChild(iframe);
  }, `${type}: moving to another document during parsing, external script`);

  async_test(t => {
    t.add_cleanup(() => {
      window.didExecute = undefined;
    });

    const iframe = document.createElement("iframe");
    iframe.onload = t.step_func(() => {
      const s = document.createElement("script");
      s.type = type;
      s.onload = t.unreached_func("onload");
      s.onerror = t.unreached_func("onerror");
      s.src = "resources/slow-flag-setter.py";

      // Start the fetch
      document.body.appendChild(s);

      // Need to delay since the "prepare a script" algorithm also contains related checks; we want to
      // test the "execute a script block" algorithm for when the fetch comes back.
      t.step_timeout(() => {
        iframe.contentDocument.body.appendChild(s);
      }, 0);

      t.step_timeout(() => {
        assert_equals(window.didExecute, undefined, "The script must not have executed in this window");
        assert_equals(iframe.contentWindow.didExecute, undefined,
          "The script must not have executed in the iframe window");
        t.done();
      }, 3000);
    });

    document.body.appendChild(iframe);
  }, `${type}: moving to another Window's document during fetching`);

  async_test(t => {
    t.add_cleanup(() => {
      window.didExecute = undefined;
    });

    const s = document.createElement("script");
    s.type = type;
    s.onload = t.unreached_func("onload");
    s.onerror = t.unreached_func("onerror");
    s.src = "resources/slow-flag-setter.py";

    // Start the fetch
    document.body.appendChild(s);

    // Need to delay since the "prepare a script" algorithm also contains related checks; we want to
    // test the "execute a script block" algorithm for when the fetch comes back.
    t.step_timeout(() => {
      const doc2 = document.implementation.createHTMLDocument("title");
      doc2.body.appendChild(s);
    }, 0);

    t.step_timeout(() => {
      assert_equals(window.didExecute, undefined, "The script must not have executed in this window");
      t.done();
    }, 3000);
  }, `${type}: moving to a createHTMLDocument document where scripting is disabled during fetching`);
}
</script>
