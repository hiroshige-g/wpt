<!DOCTYPE html>
<meta charset="utf-8">
<meta name="timeout" content="long">
<title>Moving script elements between documents</title>
<link rel="author" href="mailto:d@domenic.me" title="Domenic Denicola">
<link rel="help" href="https://html.spec.whatwg.org/multipage/#execute-the-script-block">

<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>

<!-- Background:

- https://www.w3.org/Bugs/Public/show_bug.cgi?id=11323
- https://github.com/whatwg/html/issues/2137
- https://github.com/whatwg/html/issues/2469
- https://github.com/whatwg/html/pull/2673

For a script, there are four associated Documents that can
potentially different:
[1] script's parser document
[2] script's node document at the beginning of #prepare-a-script
    == script's preparation-time document
[3] script's node document at the beginning of
    #execute-the-script-block
[4] script's node document at the end of
    #execute-the-script-block

This file tests cases where [1]/[2]/[3] are different.
The case where [3]/[4] are different is tested in
`moving-between-documents-during-evaluation.html`.

[1]==[2] is tested in #prepare-a-script (Step 10).
[1]==[3] and [2]==[3] is tested in #execute-the-script-block.
-->

<body>
<script>
"use strict";

function createDocument(documentType) {
  return new Promise((resolve, reject) => {
    const iframe = document.createElement("iframe");
    iframe.onload = () => {
      if (documentType === "iframe") {
        resolve([iframe.contentWindow, iframe.contentDocument]);
      } else if (documentType === "createHTMLDocument") {
        resolve([
            iframe.contentWindow,
            iframe.contentDocument.implementation.createHTMLDocument("")]);
      } else {
        reject(new Error("Invalid document type: " + documentType));
      }
    };
    document.body.appendChild(iframe);
  });
}

window.scriptErrorEventFired = false;
window.didExecute = undefined;

(async function() {
  for (const during of [
      // An inline <script> is moved during parsing before #prepare-a-script.
      // [1] != [2] == [3]
      "parsing",

      // An inline <script> is moved after parsing/#prepare-a-script but
      // before #execute-the-script-block.
      // To move such scripts, #has-a-style-sheet-that-is-blocking-scripts
      // is utilized.
      // [1] == [2] != [3]
      "blocked by stylesheet",

      // An inline <script> is moved during parsing, but moved back again
      // to the original Document.
      // [1] == [3] != [2]
      "parsing but moved back",

      // An external <script> is moved after parsing/#prepare-a-script but
      // before #execute-the-script-block.
      // [1] == null, [2] != [3]
      "successful fetch", "failed fetch",
  ]) {
    for (const hasParseError of [false, true]) {
      for (const destType of ["iframe", "createHTMLDocument"]) {
        for (const type of ["text/javascript", "module"]) {
          if (during === "failed fetch" && hasParseError) {
            // Skip; Parse errors can't occur for failed fetches.
            continue;
          }

          const description =
              `Move during ${during}` +
              (hasParseError ? " with parse error" : "") +
              ` to ${destType} document: ${type}`;
          const t = async_test(description + ", script evaluation");
          const tScriptLoadEvent = async_test(description + ", script load");
          const tScriptErrorEvent = async_test(description + ", script error");
          const tWindowErrorEvent = async_test(description + ", window error");

          const [sourceWindow, sourceDocument] =
              await createDocument("iframe");
          const [destWindow, destDocument] = await createDocument(destType);

          let scriptErrorEventFired = false;

          sourceWindow.didExecute = undefined;
          sourceWindow.tScriptLoadEvent = tScriptLoadEvent;
          sourceWindow.tScriptErrorEvent = tScriptErrorEvent;
          sourceWindow.onerror = tWindowErrorEvent.unreached_func(
              "Window error event shouldn't fired on source window");
          destWindow.didExecute = undefined;
          destWindow.tScriptLoadEvent = tScriptLoadEvent;
          destWindow.tScriptErrorEvent = tScriptErrorEvent;
          destWindow.onerror = tWindowErrorEvent.unreached_func(
              "Window error event shouldn't fired on destination window");

          const shouldScriptErrorEventFired = false;
          // TODO: Temporarily set to false just to test behaviors on
          // the current browsers.
          // during === "failed fetch" && destType === "iframe";

          if (during === "parsing" ||
              during === "parsing but moved back" ||
              during === "blocked by stylesheet") {

            // If scripts should be moved after #prepare-a-script before
            // #execute-the-script-block, we add a style sheet that is
            // blocking scripts.
            if (during === "blocked by stylesheet" ||
                during === "parsing but moved back") {
              sourceDocument.write(
                  `<link rel="stylesheet"
                    href="resources/slow-flag-setter.py?result=css&cache=${Math.random()}">
                   </link><body></body>`);
              // Due to https://crbug.com/1034176, Chromium needs
              // blocking stylesheets also in the destination Documents.
              destDocument.write(
                  `<link rel="stylesheet"
                    href="resources/slow-flag-setter.py?result=css&cache=${Math.random()}">
                   </link><body></body>`);
              destDocument.close();
            }

            sourceDocument.write("<streaming-element>");

            // Move between documents before #prepare-a-script.
            if (during === "parsing" ||
                during === "parsing but moved back") {
              destDocument.body.appendChild(
                sourceDocument.querySelector("streaming-element"));
            }

            sourceDocument.write(
              `<script id="s1" type="${type}"
                  onload="tScriptLoadEvent.unreached_func('onload')"
                  onerror="tScriptErrorEvent.unreached_func('onerror')">`);
            if (hasParseError) {
              sourceDocument.write("1=2 parse error");
            } else {
              sourceDocument.write("window.didExecute = true;");
            }

            // #prepare-a-script
            sourceDocument.write("<" + "/script>");

            sourceDocument.write("</streaming-element>");
            sourceDocument.close();

            // Move between documents after #prepare-a-script.
            if (during === "blocked by stylesheet") {
              destDocument.body.appendChild(
                sourceDocument.querySelector("streaming-element"));
            }
            else if (during === "parsing but moved back") {
              sourceDocument.body.appendChild(
                destDocument.querySelector("streaming-element"));
            }
          } else { // Move during fetching
            const s = sourceDocument.createElement("script");
            s.type = type;

            s.onload = tScriptLoadEvent.unreached_func("onload");
            if (shouldScriptErrorEventFired) {
              s.onerror = () => { scriptErrorEventFired = true };
            } else {
              s.onerror = tScriptErrorEvent.unreached_func("onerror");
            }

            if (during === "successful fetch") {
              if (hasParseError) {
                s.src = "resources/slow-flag-setter.py?result=parse-error";
              } else {
                s.src = "resources/slow-flag-setter.py?result=successful";
              }
            } else {
              s.src = "resources/slow-flag-setter.py?result=failed";
            }
            sourceDocument.body.appendChild(s);
            // Need to delay since the "prepare a script" algorithm also
            // contains related checks; we want to test the
            // "execute a script block" algorithm for when the fetch comes
            // back.
            t.step_timeout(() => {
              destDocument.body.appendChild(s);
            }, 0);
          }

          // As we have concurrent tests, a single global step_timeout() is
          // used instead of multiple `t.step_timeout()` etc.,
          // to avoid potential race conditions between `t.step_timeout()`s.
          step_timeout(() => {
            tScriptLoadEvent.done();
            tScriptErrorEvent.step_func_done(() => {
              if (shouldScriptErrorEventFired) {
                assert_true(scriptErrorEventFired,
                    "error event should be fired");
              }
            })();
            tWindowErrorEvent.done();
            t.step_func_done(() => {
              assert_equals(sourceWindow.didExecute, undefined,
                "The script must not have executed in source window");
              assert_equals(destWindow.didExecute, undefined,
                "The script must not have executed in destination window");
            })();
          }, 4000);
        }
      }
    }
  }

  async_test(t => {
      t.step_timeout(() => {
          assert_equals(window.didExecute, undefined,
            "The script must not have executed in the top-level window");
          assert_false(window.scriptErrorEventFired,
            "Top-level window's scriptErrorEventFired should be untouched");
          t.done();
        }, 4000);
    },
    "Sanity check around top-level Window");
})();
</script>
